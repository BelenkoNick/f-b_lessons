
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;
pragma AbiHeader expire;

import 'GamingObject.sol';
import 'BaseStation.sol';

// This is class that describes you smart contract.
contract WarUnit is GamingObject {

    address public targetAddress;
    BaseStation base;

    uint attackValue;
    
    constructor(address baseAddress) public {
        tvm.accept();
        // Constructor gets BaseStation address and creates BaseStation object with it.
        base = BaseStation(baseAddress);
        base.addUnit(this);
    }

    function attack(GamingObject addressOfTarget) public {
        tvm.accept();
        // This function gets address of potential target object, and calls takeAHit it the traget object.
        targetAddress = addressOfTarget;
        addressOfTarget.takeAHit(attackValue);
    }

    function getAttackValue(uint newAttackValue) virtual public {
        tvm.accept();
        attackValue = newAttackValue;
    }

    function getShieldValue(uint newShieldValue) virtual public override {
        tvm.accept();
        shieldValue = newShieldValue;
    }
    
    function destroyObject() internal override {
        tvm.accept();
        sendTransactionAndDestroy();
        // If Unit is dead, destroy Unit itself and call Bases function to delete Unit from struct.
        base.destroyUnit();
    }

    function destroyUnitIfBaseIsDead() external override {
        require(msg.sender == base);
        tvm.accept();
        // This function is called from the Unit's BaseStation when it destroyed and checks if the caller is Unit's BaseStation, then destroys Unit.
        destroyObject();
    }
}